#! /bin/zsh

USAGE='Usage: ffconv [OPTS] PATH
  -f	force a re-encode, even if already using H264/AAC streams
  -a	audio quality [0-100]
  -A	drop audio channel
  -T	don'"'"'t trash the input file
  -W	resize to this horizontal pixel size
  -H	resize to this vertical pixel size
  -s	encode start time in 0:01:23 time format (default is 0s)
  -e	encode end time in 0:01:23 time format (default is movie length)
  -d	encode duration in seconds
  -F	fade in/out duration in seconds (default is 1s)
  -b	encode transport file for concatenating together
  -B	concatenate all transport files for this movie
  -h	display this message

  Re-encode a movie to H264/MP4 with simpler CLI'

FORCE=0
AUDIOQ=
DROP_AUDIO=0
DONT_TRASH=0
NEW_WIDTH=0
NEW_HEIGHT=0
START_TIME=0
END_TIME=
DURATION=
FADE_DURATION=1
START=
TRANSPORT_MODE=0
CONCAT_MODE=0

while getopts 'fa:ATW:H:s:e:d:F:h:NbB' params
do
	case $params in
		f ) FORCE=1;;
		a ) AUDIOQ=$OPTARG;;
		A ) DROP_AUDIO=1;;
		T ) DONT_TRASH=1;;
		W ) NEW_WIDTH=$OPTARG;;
		H ) NEW_HEIGHT=$OPTARG;;
		s ) START_TIME=$OPTARG;;
		e ) END_TIME=$OPTARG;;
		d ) DURATION=$OPTARG;;
		F ) FADE_DURATION=$OPTARG;;
		b ) TRANSPORT_MODE=1;;
		B ) CONCAT_MODE=1;;
		h ) echo "$USAGE" && return 1;;
	esac
done
shift $((OPTIND-1))

##################################################

if [[ $# -eq 0 ]]; then
	echo $USAGE
	return 1
fi

# Validate file exists
if [[ ! -f $1 ]]; then
	echo 'File does not exist!'
	exit 44
fi

if [[ -n $END_TIME && -n $DURATION ]]; then
	echo 'You cannot pass both -e and -d'
	exit 45
fi

# Alias GNU touch for this script, when it's present (via Homebrew)
if command -v gtouch >/dev/null 2>&1; then
	function touch {
		gtouch $@
	}
fi

# set NO_TRASH on linux
if [[ $(uname) == 'Linux' ]]; then
	DONT_TRASH=1
fi

##################################################

function info {
	>&2 echo -e "\e[32m$1\e[0m"
}

function debug {
	# DEBUG logging controlled by env var
	if [[ -n $DEBUG ]]; then
		>&2 echo -e "\e[33m$1\e[0m"
	fi
}

function fin() {
	local input_file=$1
	local output_file=$2

	if [[ $TRANSPORT_MODE -eq 0 ]] && [[ $CONCAT_MODE -eq 0 ]]; then
		# copy the EXIF date data
		local date="$(exiftool -t -s -d "%Y-%m-%d %H:%M:%S" -MediaCreateDate -CreateDate -FileModifyDate "$input_file" | awk '!/0000:00:00/ {print $2" "$3}' | head -1)"
		if [[ -n $date ]]; then
			echo "Setting EXIF timestamp to $date"
			exiftool "-AllDates=$date" -overwrite_original "$output_file"
			touch -d "$date" "$output_file"
		fi
	fi

	if command -v trash >/dev/null 2>&1 && [[ $DONT_TRASH -eq 0 ]]; then
		trash "$input_file"
	fi
}

function time_to_secs {
	hours=$(echo $1 | cut -d':' -f 1)
	mins=$(echo $1 | cut -d':' -f 2)
	secs=$(echo $1 | cut -d':' -f 3)

	if [[ -z $secs ]]; then
		secs=$mins
		mins=$hours
		hours=
	fi

	echo $(( (hours*60*60) + (mins*60) + secs ))
}

function get_transport_filename() {
	setopt localoptions +o nomatch
	setopt localoptions histsubstpattern

	# replace spaces with underscores for the transport files
	local base_file=${1:gs/[ ,]/_}

	# increment suffix based on count of existing .ts files
	count=$(ls ${base_file%.*}*.ts 2>/dev/null | wc -l)
	count=$((count+1))
	suffix=${(l:2::0:)count}

	echo "${base_file%.*}_${suffix}.ts"
}

function gather_transport_files() {
	setopt localoptions histsubstpattern

	# replace spaces with underscores for the transport files
	local base_file=${1:gs/[ ,]/_}

	set -A concat

	for F in ${base_file%.*}*.ts; do
		concat+=("$F")
	done

	echo ${(j:|:)concat}
}

function get_target_bitrate {
	##
	# Determine target bitrate for a h264_videotoolbox encode
	#
	local width=$1
	local height=$2
	local source_bitrate=$3

	debug "get_target_bitrate $width $height $source_bitrate"

	# Define target bitrate for given resolutions
	# https://stackoverflow.com/a/72277037/425050
	declare -A bitrates
	bitrates[720]=5250000
	bitrates[1080]=7500000
	bitrates[2160]=25000000

	# Multiply target bitrate by Q coefficient
	local integer target_bitrate=$(( bitrates[$width] ))
	debug "TARGET1: ${target_bitrate}"

	# Handle landscape movies
	if [[ $target_bitrate -eq 0 ]]; then
		target_bitrate=$(( bitrates[$height] ))
		debug "TARGET2: ${target_bitrate}"
	fi

	# If target is greater than the source movie, select the source movie bitrate
	# If target is zero, select the source movie bitrate
	if [[ $target_bitrate -gt $source_bitrate || $target_bitrate -eq 0 ]]; then
		target_bitrate=$source_bitrate
		debug "TARGET3: ${target_bitrate}"
	fi
	echo $target_bitrate
}

##################################################

# add first script parameter to a named variable
INPUT_FILE=$1

VCMD='-c:v copy'
ACMD='-c:a copy'

# Query video stream zero for codec, resolution & bitrate of source file
vstream_probe=$( ffprobe -v error -select_streams v -show_entries stream=codec_name,width,height,bit_rate -of csv=p=0 "$INPUT_FILE" | head -1 )
debug "VSTREAM_PROBE: $vstream_probe"

# Split into component vars
vstream_meta=(${(s/,/)vstream_probe})
VCODEC=$vstream_meta[1]
WIDTH=$vstream_meta[2]
HEIGHT=$vstream_meta[3]
SOURCE_BITRATE=$vstream_meta[4]

# Query audio stream zero for codec
astream_probe=$( ffprobe -v error -select_streams a -show_entries stream=codec_name -of csv=p=0 "$INPUT_FILE" | head -1 )
debug "ASTREAM_PROBE: $astream_probe"
# Split into component vars
astream_meta=(${(s/,/)astream_probe})
ACODEC=$astream_meta[1]

info "${INPUT_FILE:t} ${VCODEC} ${WIDTH}x${HEIGHT} ${SOURCE_BITRATE} ${ACODEC}"

TARGET_BITRATE=$(get_target_bitrate $WIDTH $HEIGHT $SOURCE_BITRATE)
debug "TARGET_BITRATE: ${TARGET_BITRATE}"

# filter array including baseline deinterlace filter
set -A VFILTER 'yadif'

# if end time supplied, convert to DURATION in seconds
# default START_TIME is zero
if [[ -n $END_TIME ]]; then
	DURATION=$(( $(time_to_secs $END_TIME) - $(time_to_secs $START_TIME) ))
fi

# Set encode start time
if [[ $START_TIME -gt 0 ]]; then
	START="-ss $START_TIME"

	# fade in movie at specified time
	VFILTER+=("fade=t=in:st=0:d=$FADE_DURATION")
else
	START="-ss 0:00:00"
fi

# set encode end time
if [[ -n $DURATION ]]; then
	START="$START -t $DURATION"

	# fade out after duration seconds
	FADE_OUT_START=$(( DURATION - FADE_DURATION ))
	VFILTER+=("fade=t=out:st=$FADE_OUT_START:d=$FADE_DURATION")
fi

# convert to H264
if [[ $VCODEC != 'h264' || -n $START || $NEW_WIDTH -gt 0 || $NEW_HEIGHT -gt 0 || $FORCE -eq 1 ]]; then
	# scale filter
	if [[ $NEW_WIDTH -gt 0 && $NEW_HEIGHT -gt 0 ]]; then
		VFILTER+=("scale=$NEW_WIDTH:$NEW_HEIGHT")

	elif [[ $NEW_WIDTH -gt 0 ]]; then
		# calculate new height
		integer NEW_HEIGHT=$(( int(NEW_WIDTH * HEIGHT / WIDTH) ))
		# ensure is divisible by 2
		if [[ $(( NEW_HEIGHT % 2 )) -eq 1 ]]; then
			(( NEW_HEIGHT -= 1 ))
		fi

		VFILTER+=("scale=$NEW_WIDTH:$NEW_HEIGHT")

	elif [[ $NEW_HEIGHT -gt 0 ]]; then
		# calculate new width
		integer NEW_WIDTH=$(( int(NEW_HEIGHT * WIDTH / HEIGHT) ))
		# ensure is divisible by 2
		if [[ $(( NEW_WIDTH % 2 )) -eq 1 ]]; then
			(( NEW_WIDTH -= 1 ))
		fi

		VFILTER+=("scale=$NEW_WIDTH:$NEW_HEIGHT")
	fi

	# create encode options string
	VCMD="-c:v h264_videotoolbox -b:v ${TARGET_BITRATE} -filter:v '${(j:,:)VFILTER}'"
fi

if [[ $DROP_AUDIO -eq 1 ]]; then
	# Completely drop audio
	ACMD='-an'

elif [[ $ACODEC != 'aac' ]]; then
	# Convert to AAC audiotoolbox
	ACMD='-c:a aac_at'

	# Set audio stream quality
	if [[ -n $AUDIOQ ]]; then
		ACMD="${ACMD} -q:a ${AUDIOQ}"
	fi
fi

# Name the new file with target bitrate
if [[ ! $VCMD =~ (.*)copy$ ]]; then
	SUFFIX=".h264_$(( TARGET_BITRATE / 1000 ))"
fi

# track input file for later trashing
TRASH_FILE="$INPUT_FILE"

if [[ $CONCAT_MODE -eq 1 ]]; then
	INPUT_FILE="concat:$(gather_transport_files "$INPUT_FILE")"
	TRANSPORT="-c copy -bsf:a aac_adtstoasc"
	VCMD=''
	ACMD=''
	START=''
	SUFFIX='-concat'
fi

if [[ $TRANSPORT_MODE -eq 1 ]]; then
	# transport encode options
	TRANSPORT='-bsf:v h264_mp4toannexb -f mpegts'

	# set the output filename
	OUTPUT_FILE="$(get_transport_filename "$INPUT_FILE")"
else
	# set the output filename
	OUTPUT_FILE="${1%.*}${SUFFIX}.mp4"
fi

# build FFMPEG command
FFMPEG="time ffmpeg $START -i \"$INPUT_FILE\" $VCMD $ACMD $TRANSPORT \"$OUTPUT_FILE\""
echo "$FFMPEG"

# if either stream needs converting, or --force supplied
if [[ ! $VCMD =~ (.*)copy$ || ! $ACMD =~ (.*)copy$ || $FORCE -eq 1 ]]; then
	if eval "$FFMPEG"; then
		fin "$TRASH_FILE" "$OUTPUT_FILE"
	fi

else
	# else if already MP4 do nothing
	if [[ $INPUT_FILE =~ (.*)mp4$ ]]; then
		print 'Nothing to do'
	else
		# switch container to MP4
		if /usr/local/bin/ffmpeg -i "$INPUT_FILE" -c copy "${1%.*}.mp4"; then
			fin "$TRASH_FILE" "$OUTPUT_FILE"
		fi
	fi
fi
