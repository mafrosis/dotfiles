#! /bin/zsh

USAGE='Usage: ffconv [OPTS] PATH
  -c	manually set the CRF value
  -f	force a re-encode, even if already using H264/AAC streams
  -a	audio quality [0-100]
  -A	drop audio channel
  -T	don'"'"'t trash the input file
  -N	hide the dunzo message
  -W	resize to this horizontal pixel size
  -H	resize to this vertical pixel size
  -s	encode start time in 0:01:23 time format (default is 0s)
  -e	encode end time in 0:01:23 time format (default is movie length)
  -d	encode duration in seconds
  -F	fade in/out duration in seconds (default is 1s)
  -b	encode transport file for concatenating together
  -B	concatenate all transport files for this movie
  -h	display this message

  Re-encode a movie to H264/MP4 using standard film presets'

if [[ $# -eq 0 ]]; then
	echo "$USAGE"
	return 1
fi

if [[ -x /usr/local/bin/gtouch ]]; then
	function touch {
		gtouch "$@"
	}
fi

CRF=21
FORCE=0
AUDIOQ=70
DROP_AUDIO=0
DONT_TRASH=0
NO_DUNZO=0
NEW_WIDTH=0
NEW_HEIGHT=0
START_TIME=0
END_TIME=
DURATION=
FADE_DURATION=1
START=
TRANSPORT_MODE=0
CONCAT_MODE=0

while getopts 'c:fa:ATW:H:s:e:d:F:h:NbB' params
do
	case $params in
		c ) CRF=$OPTARG;;
		f ) FORCE=1;;
		a ) AUDIOQ=1;;
		A ) DROP_AUDIO=1;;
		T ) DONT_TRASH=1;;
		W ) NEW_WIDTH=$OPTARG;;
		H ) NEW_HEIGHT=$OPTARG;;
		s ) START_TIME=$OPTARG;;
		e ) END_TIME=$OPTARG;;
		d ) DURATION=$OPTARG;;
		F ) FADE_DURATION=$OPTARG;;
		N ) NO_DUNZO=1;;
		b ) TRANSPORT_MODE=1;;
		B ) CONCAT_MODE=1;;
		h ) echo "$USAGE" && return 1;;
	esac
done
shift $((OPTIND-1))

##################################################

# validate file exists
if [[ ! -f $1 ]]; then
	echo 'File does not exist!'
	exit 44
fi

if [[ ! -z $END_TIME ]] && [[ ! -z $DURATION ]]; then
	echo 'You cannot pass both -e and -d'
	exit 45
fi

# set NO_TRASH & NO_DUNZO on linux
if [[ $(uname) == 'Linux' ]]; then
	DONT_TRASH=1
	NO_DUNZO=1
fi


function fin() {
	local INPUT_FILE="$1"
	local OUTPUT_FILE="$2"

	if [[ $TRANSPORT_MODE -eq 0 ]] && [[ $CONCAT_MODE -eq 0 ]]; then
		# copy the EXIF date data
		DATE="$(exiftool -t -s -d "%Y-%m-%d %H:%M:%S" -MediaCreateDate -CreateDate -FileModifyDate "$INPUT_FILE" | awk '!/0000:00:00/ {print $2" "$3}' | head -1)"
		if [[ ! -z $DATE ]]; then
			echo "Setting EXIF timestamp to $DATE"
			exiftool "-AllDates=$DATE" -overwrite_original "$OUTPUT_FILE"
			touch -d "$DATE" "$OUTPUT_FILE"
		fi
	fi

	if [[ $NO_DUNZO -eq 0 ]]; then
		dunzo "Finished transcoding $OUTPUT_FILE" 'ffconv' "$PWD/$(dirname "$OUTPUT_FILE")"
	fi
	if [[ $DONT_TRASH -eq 0 ]]; then
		trash "$INPUT_FILE"
	fi
}

function time_to_secs {
	HOURS=$(echo "$1" | cut -d':' -f 1)
	MINS=$(echo "$1" | cut -d':' -f 2)
	SECS=$(echo "$1" | cut -d':' -f 3)

	if [[ -z $SECS ]]; then
		SECS="$MINS"
		MINS="$HOURS"
		HOURS=""
	fi

	echo $(( (HOURS*60*60) + (MINS*60) + $SECS ))
}

function get_transport_filename() {
	setopt localoptions +o nomatch
	setopt localoptions histsubstpattern

	# replace spaces with underscores for the transport files
	local BASE_FILE=${1:gs/[ ,]/_}

	# increment suffix based on count of existing .ts files
	COUNT=$(ls ${BASE_FILE%.*}*.ts 2>/dev/null | wc -l)
	COUNT=$((COUNT+1))
	SUFFIX=${(l:2::0:)COUNT}

	echo "${BASE_FILE%.*}_${SUFFIX}.ts"
}

function gather_transport_files() {
	setopt localoptions histsubstpattern

	# replace spaces with underscores for the transport files
	local BASE_FILE=${1:gs/[ ,]/_}

	set -A CONCAT

	for F in ${BASE_FILE%.*}*.ts; do
		CONCAT+=("$F")
	done

	echo ${(j:|:)CONCAT}
}

##################################################

# add first script parameter to a named variable
local INPUT_FILE="$1"

VCMD='-c:v copy'
ACMD='-c:a copy'

# analyse input file to determine existing stream codecs
VSTREAM_DATA=$( ffprobe -i "$INPUT_FILE" -show_streams -select_streams v:0 2>&1 )
VCODEC=$( echo "$VSTREAM_DATA" | grep codec_name | cut -d = -f 2 )
ACODEC=$( ffprobe -i "$INPUT_FILE" -show_streams -select_streams a:0 2>&1 | grep codec_name | cut -d = -f 2 )

# filter array including baseline deinterlace filter
set -A VFILTER 'yadif'

# if end time supplied, convert to DURATION in seconds
# default START_TIME is zero
if [[ ! -z $END_TIME ]]; then
	DURATION=$(( $(time_to_secs $END_TIME) - $(time_to_secs $START_TIME) ))
fi

# set encode start time
if [[ ! -z $START_TIME ]]; then
	START="-ss $START_TIME"

	# fade in movie at specified time
	VFILTER+=("fade=t=in:st=0:d=$FADE_DURATION")
else
	START="-ss 0:00:00"
fi

# set encode end time
if [[ ! -z $DURATION ]]; then
	START="$START -t $DURATION"

	# fade out after duration seconds
	FADE_OUT_START=$(( DURATION - FADE_DURATION ))
	VFILTER+=("fade=t=out:st=$FADE_OUT_START:d=$FADE_DURATION")
fi

# convert to H264
if [[ $VCODEC != 'h264' || ! -z $START || $NEW_WIDTH -gt 0 || $NEW_HEIGHT -gt 0 || $FORCE -eq 1 ]]; then
	# scale filter
	if [[ $NEW_WIDTH -gt 0 && $NEW_HEIGHT -gt 0 ]]; then
		VFILTER+=("scale=$NEW_WIDTH:$NEW_HEIGHT")

	elif [[ $NEW_WIDTH -gt 0 ]]; then
		# extract movie resolution
		WIDTH=$( echo "$VSTREAM_DATA" | grep '^width' | cut -d = -f 2 )
		HEIGHT=$( echo "$VSTREAM_DATA" | grep '^height' | cut -d = -f 2 )

		# calculate new height
		integer NEW_HEIGHT=$(( NEW_WIDTH * HEIGHT / WIDTH ))
		# ensure is divisible by 2
		if [[ $(( NEW_HEIGHT % 2 )) -eq 1 ]]; then
			(( NEW_HEIGHT -= 1 ))
		fi

		VFILTER+=("scale=$NEW_WIDTH:$NEW_HEIGHT")

	elif [[ $NEW_HEIGHT -gt 0 ]]; then
		# extract movie resolution
		WIDTH=$( echo "$VSTREAM_DATA" | grep '^width' | cut -d = -f 2 )
		HEIGHT=$( echo "$VSTREAM_DATA" | grep '^height' | cut -d = -f 2 )

		# calculate new width
		integer NEW_WIDTH=$(( NEW_HEIGHT * WIDTH / HEIGHT ))
		# ensure is divisible by 2
		if [[ $(( NEW_WIDTH % 2 )) -eq 1 ]]; then
			(( NEW_WIDTH -= 1 ))
		fi

		VFILTER+=("scale=$NEW_WIDTH:$NEW_HEIGHT")
	fi

	# create encode options string
	VCMD="-c:v libx264 -tune film -filter:v '${(j:,:)VFILTER}' -crf $CRF"
fi

# completely drop audio
if [[ $DROP_AUDIO -eq 1 ]]; then
	ACMD='-an'
elif [[ $ACODEC != 'aac' ]]; then
	ACMD="-c:a aac -q:a $AUDIOQ"
fi

# include crf in output filename
if [[ ! $VCMD =~ (.*)copy$ ]]; then
	SUFFIX="-crf${CRF}"
elif [[ $INPUT_FILE =~ (.*)mp4$ ]]; then
	SUFFIX='-reenc'
fi

# track input file for later trashing
TRASH_FILE="$INPUT_FILE"

if [[ $CONCAT_MODE -eq 1 ]]; then
	INPUT_FILE="concat:$(gather_transport_files "$INPUT_FILE")"
	TRANSPORT="-c copy -bsf:a aac_adtstoasc"
	VCMD=''
	ACMD=''
	START=''
	SUFFIX='-concat'
fi

if [[ $TRANSPORT_MODE -eq 1 ]]; then
	# transport encode options
	TRANSPORT='-bsf:v h264_mp4toannexb -f mpegts'

	# set the output filename
	OUTPUT_FILE="$(get_transport_filename "$INPUT_FILE")"
else
	# set the output filename
	OUTPUT_FILE="${1%.*}${SUFFIX}.mp4"
fi

# build FFMPEG command
FFMPEG="time ffmpeg $START -i \"$INPUT_FILE\" $VCMD $ACMD $TRANSPORT \"$OUTPUT_FILE\""
echo "$FFMPEG"

# if either stream needs converting, or --force supplied
if [[ ! $VCMD =~ (.*)copy$ || ! $ACMD =~ (.*)copy$ || $FORCE -eq 1 ]]; then
	if eval "$FFMPEG"; then
		fin "$TRASH_FILE" "$OUTPUT_FILE"
	fi

else
	# else if already MP4 do nothing
	if [[ $INPUT_FILE =~ (.*)mp4$ ]]; then
		print 'Nothing to do'
	else
		# switch container to MP4
		if /usr/local/bin/ffmpeg -i "$INPUT_FILE" -c copy "${1%.*}.mp4"; then
			fin "$TRASH_FILE" "$OUTPUT_FILE"
		fi
	fi
fi
