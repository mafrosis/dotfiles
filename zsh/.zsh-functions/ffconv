#! /bin/zsh

USAGE='Usage: ffconv [OPTS] PATH
  -f	force a re-encode, even if already using H264/AAC streams
  -c	bitrate co-efficient [0.0-1.0]
  -a	audio quality [0-100]
  -A	drop audio channel
  -T	don'"'"'t trash the input file
  -W	resize to this horizontal pixel size
  -H	resize to this vertical pixel size
  -s	encode start time in 0:01:23 time format (default is 0s)
  -e	encode end time in 0:01:23 time format (default is movie length)
  -d	encode duration in seconds
  -F	fade in/out duration in seconds (default is 1s)
  -b	encode transport file for concatenating together
  -B	concatenate all transport files for this movie
  -h	display this message

  Re-encode a movie to H264/MP4 with simpler CLI'

FORCE=0
QCOEFF=1.0
AUDIOQ=
DROP_AUDIO=0
DONT_TRASH=0
NEW_WIDTH=0
NEW_HEIGHT=0
START_TIME=0
END_TIME=
DURATION=
FADE_DURATION=1
START=
TRANSPORT_MODE=0
CONCAT_MODE=0

while getopts 'fc:a:ATW:H:s:e:d:F:h:NbB' params
do
	case $params in
		f ) FORCE=1;;
		c ) QCOEFF=$OPTARG;;
		a ) AUDIOQ=$OPTARG;;
		A ) DROP_AUDIO=1;;
		T ) DONT_TRASH=1;;
		W ) NEW_WIDTH=$OPTARG;;
		H ) NEW_HEIGHT=$OPTARG;;
		s ) START_TIME=$OPTARG;;
		e ) END_TIME=$OPTARG;;
		d ) DURATION=$OPTARG;;
		F ) FADE_DURATION=$OPTARG;;
		b ) TRANSPORT_MODE=1;;
		B ) CONCAT_MODE=1;;
		h ) echo "$USAGE" && return 1;;
	esac
done
shift $((OPTIND-1))

##################################################

if [[ $# -eq 0 ]]; then
	print $USAGE
	return 1
fi

function error {
	>&2 print "\e[31m$1\e[0m"
}

# Validate file exists
if [[ ! -f $1 ]]; then
	error 'File does not exist!'
	return 44
fi

if [[ -n $END_TIME && -n $DURATION ]]; then
	error 'You cannot pass both -e and -d'
	return 45
fi

# Alias GNU commands for this script, which are provided by coreutils in Homebrew
for cmd in touch date; do
	if command -v g${cmd} >/dev/null 2>&1; then
		function ${cmd} {
			g${cmd} $@
		}
	fi
done

# Set NO_TRASH on linux
if [[ $(uname) == 'Linux' ]]; then
	DONT_TRASH=1
fi

##################################################

zmodload zsh/mathfunc

function info {
	>&2 echo -e "\e[32m$1\e[0m"
}

function debug {
	# DEBUG logging controlled by env var
	if [[ -n $DEBUG ]]; then
		>&2 echo -e "\e[33m$1\e[0m"
	fi
}

function fin() {
	local input_file=$1
	local output_file=$2

	debug "FIN: $input_file $output_file"

	if [[ $TRANSPORT_MODE -eq 0 ]] && [[ $CONCAT_MODE -eq 0 ]]; then
		# Extract EXIF from the input file
		exif_date=$(read_exif_date $input_file)

		if [[ -n $exif_date ]]; then
			info "Setting EXIF timestamp to $exif_date"
			write_exif_date $output_file $exif_date
		fi
	fi

	if command -v trash >/dev/null 2>&1 && [[ $DONT_TRASH -eq 0 ]]; then
		trash "$input_file"
	fi

	# Echo new filename on stdout for wrapping scripts
	echo $output_file
}

function read_exif_date {
	local filepath=$1

	# Try DateTimeOriginal first, as it's in local TZ
	dt=$(exiftool -m -s2 -d "%Y%m%d_%H%M%S" -DateTimeOriginal $filepath | cut -d' ' -f2)

	if [[ -z $dt ]]; then
		# Fallback to CreateDate, which is in UTC and must be adjusted
		dt=$(exiftool -m -s2 -d "%Y%m%d %H:%M:%S" -CreateDate $filepath | cut -d' ' -f2,3)

		# Convert from UTC to AEST
		dt2=$(date --date='TZ="Australia/Melbourne" '$dt' Z' +%Y%m%d_%H%M%S)

		# Log
		info "Converted ${filepath:t} into AEST. '$dt' -> '$dt2'. Please validate."
		dt=$dt2
	fi

	echo $dt
}

function write_exif_date {
	local filepath=$1
	local date=$2

	# Write all dates in the EXIF
	exiftool -q -AllDates=$date -overwrite_original $filepath
}

function time_to_secs {
	hours=$(echo $1 | cut -d':' -f 1)
	mins=$(echo $1 | cut -d':' -f 2)
	secs=$(echo $1 | cut -d':' -f 3)

	if [[ -z $secs ]]; then
		secs=$mins
		mins=$hours
		hours=
	fi

	echo $(( (hours*60*60) + (mins*60) + secs ))
}

function get_transport_filename() {
	setopt localoptions +o nomatch
	setopt localoptions histsubstpattern

	# Replace spaces with underscores for the transport files
	local base_file=${1:gs/[ ,]/_}

	# Increment suffix based on count of existing .ts files
	count=$(ls ${base_file%.*}*.ts 2>/dev/null | wc -l)
	count=$((count+1))
	suffix=${(l:2::0:)count}

	echo "${base_file%.*}_${suffix}.ts"
}

function gather_transport_files() {
	setopt localoptions histsubstpattern

	# Replace spaces with underscores for the transport files
	local base_file=${1:gs/[ ,]/_}

	set -A concat

	for F in ${base_file%.*}*.ts; do
		concat+=("$F")
	done

	echo ${(j:|:)concat}
}

function get_target_bitrate {
	##
	# Determine target bitrate for a h264_videotoolbox encode
	#
	local width=$1
	local height=$2
	local source_bitrate=$3
	local qcoeff=$4

	debug "get_target_bitrate $width $height $source_bitrate"

	# Define target bitrate for given resolutions
	# https://stackoverflow.com/a/72277037/425050
	declare -A bitrates
	bitrates[720]=5250000
	bitrates[1080]=7500000
	bitrates[2160]=25000000

	# Multiply target bitrate by Q coefficient
	local integer target_bitrate=$(( int(bitrates[$width] * qcoeff) ))
	debug "TARGET1: ${target_bitrate}"

	# Handle landscape movies
	if [[ $target_bitrate -eq 0 ]]; then
		target_bitrate=$(( int(bitrates[$height] * qcoeff) ))
		debug "TARGET2: ${target_bitrate}"
	fi

	# If target is greater than the source movie, select the source movie bitrate
	# If target is zero, select the source movie bitrate
	if [[ $target_bitrate -gt $source_bitrate || $target_bitrate -eq 0 ]]; then
		target_bitrate=$(( int(source_bitrate * qcoeff) ))
		debug "TARGET3: ${target_bitrate}"
	fi
	echo $target_bitrate
}

##################################################

# Add first script parameter to a named variable
INPUT_FILE=$1

VCMD='-c:v copy'
ACMD='-c:a copy'

# Query video stream zero for codec, resolution & bitrate of source file
vstream_probe=$( ffprobe -v error -select_streams v -show_entries stream=codec_name,width,height,bit_rate -of csv=p=0 "$INPUT_FILE" | head -1 )
debug "VSTREAM_PROBE: $vstream_probe"

# Split into component vars
vstream_meta=(${(s/,/)vstream_probe})
VCODEC=$vstream_meta[1]
WIDTH=$vstream_meta[2]
HEIGHT=$vstream_meta[3]
SOURCE_BITRATE=$vstream_meta[4]

# Query audio stream zero for codec
astream_probe=$( ffprobe -v error -select_streams a -show_entries stream=codec_name -of csv=p=0 "$INPUT_FILE" | head -1 )
debug "ASTREAM_PROBE: $astream_probe"
# Split into component vars
astream_meta=(${(s/,/)astream_probe})
ACODEC=$astream_meta[1]

info "${INPUT_FILE:t} ${VCODEC} ${WIDTH}x${HEIGHT} ${SOURCE_BITRATE} ${ACODEC}"
debug "QUAL COEFF: ${QCOEFF}"

TARGET_BITRATE=$(get_target_bitrate $WIDTH $HEIGHT $SOURCE_BITRATE $QCOEFF)
debug "TARGET_BITRATE: ${TARGET_BITRATE} q=${QCOEFF}"

# Init filter array including baseline deinterlace filter
set -A VFILTER 'yadif'

# If end time supplied, convert to DURATION in seconds
# Default START_TIME is zero
if [[ -n $END_TIME ]]; then
	DURATION=$(( $(time_to_secs $END_TIME) - $(time_to_secs $START_TIME) ))
fi

# Set encode start time
if [[ $START_TIME -gt 0 || $TRANSPORT_MODE -eq 1 ]]; then
	START="-ss $START_TIME"

	# Fade in movie at specified time
	VFILTER+=("fade=t=in:st=0:d=$FADE_DURATION")
else
	START="-ss 0:00:00"
fi

# Set encode end time
if [[ -n $DURATION ]]; then
	START="$START -t $DURATION"

	# Fade out after duration seconds
	FADE_OUT_START=$(( DURATION - FADE_DURATION ))
	VFILTER+=("fade=t=out:st=$FADE_OUT_START:d=$FADE_DURATION")
fi

# Convert to H264
if [[ $VCODEC != 'h264' || -n $START || $NEW_WIDTH -gt 0 || $NEW_HEIGHT -gt 0 || $FORCE -eq 1 ]]; then
	# Scale filter
	if [[ $NEW_WIDTH -gt 0 && $NEW_HEIGHT -gt 0 ]]; then
		VFILTER+=("scale=$NEW_WIDTH:$NEW_HEIGHT")

	elif [[ $NEW_WIDTH -gt 0 ]]; then
		# Calculate new height
		integer NEW_HEIGHT=$(( int(NEW_WIDTH * HEIGHT / WIDTH) ))
		# Ensure is divisible by 2
		if [[ $(( NEW_HEIGHT % 2 )) -eq 1 ]]; then
			(( NEW_HEIGHT -= 1 ))
		fi

		VFILTER+=("scale=$NEW_WIDTH:$NEW_HEIGHT")

	elif [[ $NEW_HEIGHT -gt 0 ]]; then
		# Calculate new width
		integer NEW_WIDTH=$(( int(NEW_HEIGHT * WIDTH / HEIGHT) ))
		# Ensure is divisible by 2
		if [[ $(( NEW_WIDTH % 2 )) -eq 1 ]]; then
			(( NEW_WIDTH -= 1 ))
		fi

		VFILTER+=("scale=$NEW_WIDTH:$NEW_HEIGHT")
	fi

	# Create encode options string
	VCMD="-c:v h264_videotoolbox -b:v ${TARGET_BITRATE} -filter:v '${(j:,:)VFILTER}'"
fi

if [[ $DROP_AUDIO -eq 1 ]]; then
	# Completely drop audio
	ACMD='-an'

elif [[ $ACODEC != 'aac' ]]; then
	# Convert to AAC audiotoolbox
	ACMD='-c:a aac_at'

	# Set audio stream quality
	if [[ -n $AUDIOQ ]]; then
		ACMD="${ACMD} -q:a ${AUDIOQ}"
	fi
fi

# Name the new file with target bitrate
if [[ ! $VCMD =~ (.*)copy$ ]]; then
	SUFFIX=".h264_$(( TARGET_BITRATE / 1000 ))"
fi

# Track input file for later trashing
TRASH_FILE="$INPUT_FILE"

if [[ $CONCAT_MODE -eq 1 ]]; then
	INPUT_FILE="concat:$(gather_transport_files "$INPUT_FILE")"
	TRANSPORT="-c copy -bsf:a aac_adtstoasc"
	VCMD=''
	ACMD=''
	START=''
	SUFFIX='-concat'
fi

if [[ $TRANSPORT_MODE -eq 1 ]]; then
	# Transport encode options
	TRANSPORT='-bsf:v h264_mp4toannexb -f mpegts'

	# Set the output filename
	OUTPUT_FILE="$(get_transport_filename "$INPUT_FILE")"
else
	# Set the output filename
	OUTPUT_FILE="${1%.*}${SUFFIX}.mp4"
fi

# Build FFMPEG command
FFMPEG="time ffmpeg $START -i \"$INPUT_FILE\" $VCMD $ACMD $TRANSPORT \"$OUTPUT_FILE\""
echo "$FFMPEG"

# If either stream needs converting, or --force supplied
if [[ ! $VCMD =~ (.*)copy$ || ! $ACMD =~ (.*)copy$ || $FORCE -eq 1 ]]; then
	if eval "$FFMPEG"; then
		fin "$TRASH_FILE" "$OUTPUT_FILE"
	fi

else
	# Else if already MP4 do nothing
	if [[ $INPUT_FILE =~ (.*)mp4$ ]]; then
		print 'Nothing to do'
	else
		# Switch container to MP4
		if /usr/local/bin/ffmpeg -i "$INPUT_FILE" -c copy "${1%.*}.mp4"; then
			fin "$TRASH_FILE" "$OUTPUT_FILE"
		fi
	fi
fi
